


## 算法

贪心用于只需考虑眼前的情况，比如钞票面额是:1、5、10、20、50的找零

另一组面额贪心却不可以:1、5、11
找15应该3*5
因此，用f(n)代表凑出n所需最少钞票数量，有:
f(n)=min{f(n-1),f(n-5),f(n-11)}+1
此时只需从f(0)开始算到f(n)即可得到结果。


因此核心思想:
将一个问题拆成几个子问题，分别求解这些子问题，即可推断出大问题的解。从小到大求，大依赖小的结果。


能将大问题拆成几个小问题，且满足无后效性、最优子结构性质。

无后效性:
一旦f(n)确定，如何凑出f(n)就再也用不着了。
如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响。

最优子结构:
大问题的最优解可以由小问题的最优解推出，这个性质叫做“最优子结构性质”。

核心为尽力缩小解空间。

思路:

提前需要判断可行性，找出推导公式

设计状态
设计转移





## 示例

### Regular Expression Matching
leetcode第10题
大意为手写正则匹配，一开始的思路我想到编译原理的状态转化机那边去了...

注意该问题，俩串可以分为字串匹配，且子串匹配后只需匹配结果不用过程
递推公式有:

当前p最新为*时：
    子f[i][j - 2]为true时当前长度为true——*取0
    当前s最新匹配p最新上一个——.或字符，且子f[i - 1][j]匹配时，f[i][j]为true
当前p最新不是*时:
    子f[i - 1][j - 1]匹配且当前新字符匹配， f[i][j]为true

一定与子相关





```
class Solution {
public:
    bool isMatch(string s, string p) {

        //f[i][j] 表示s[i]能否匹配p[j]，i、j表示长度，因此数组+1，且在字串中对应位置时要-1
        int m = s.size(), n = p.size();
        //参数(大小、初始值)
        vector<vector<bool>> f(m + 1, vector<bool>(n + 1, false));//默认都是不匹配，必须vector、动态不知大小无法静态确定访问 
        
        f[0][0] = true;//二者为0为匹配
        

        //当p为0时，都是不匹配
        for (int i = 1; i <= m; i++)
            f[i][0] = false;

        //当s为0时，j>1且字串当前为*时，为字串f[0][j-2]的结果
        for (int j = 1; j <= n; j++)
            f[0][j] = j > 1 && '*' == p[j - 1] && f[0][j - 2];
        

        //长度从s 1-m  p 1-n
        for (int i = 1; i <= m; i++)
            for (int j = 1; j <= n; j++)
                if (p[j - 1] != '*')
                    //.或者普通字符
                    //当子匹配，且当前位置匹配或当前为.时，当前为串匹配
                    f[i][j] = f[i - 1][j - 1] && (s[i - 1] == p[j - 1] || '.' == p[j - 1]);
                else
                    //当前为*
                    //子f[i][j - 2]：*取0可匹配  或  当前匹配*前且子匹配，这里的子必须是j，因为当前匹配了一个字符，不影响子，子可匹配0到多个。
                    f[i][j] = f[i][j - 2] || (s[i - 1] == p[j - 2] || '.' == p[j - 2]) && f[i - 1][j];
        
        return f[m][n];
    }
};

```


### 